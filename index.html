// src/App.jsx

import React, { useEffect, useState, useCallback, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, doc, setDoc, getDoc } from 'firebase/firestore';

// üîë CONFIGURACI√ìN FINAL: CARGA DESDE VARIABLES DE ENTORNO
// Nunca subas las claves directamente a GitHub.
const firebaseConfig = {
  // Aseg√∫rate de que las variables de entorno comiencen con VITE_ si usas Vite
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,  
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID, 
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID
};

const appId = firebaseConfig.projectId; 
const initialAuthToken = null; 

// Utility to generate a consistent color based on userId
const generateColor = (str) => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  let color = '#';
  for (let i = 0; i < 3; i++) {
    const value = (hash >> (i * 8)) & 0xFF;
    color += ('00' + value.toString(16)).substr(-2);
  }
  return color;
};

// Componente principal de la aplicaci√≥n de chat
const App = () => {
  const [db, setDb] = useState(null);
  const [currentUser, setCurrentUser] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [status, setStatus] = useState('Inicializando Firebase...');
  const messagesEndRef = useRef(null);

  // 1. Inicializaci√≥n de Firebase y Autenticaci√≥n
  useEffect(() => {
    // Validaci√≥n inicial de la clave
    if (!firebaseConfig.apiKey) {
      setStatus('Error: La Clave API no est√° definida. Verifica tu archivo .env.');
      console.error('firebaseConfig:', firebaseConfig);
      return;
    }

    let initializedAuth = null;
    let unsubscribeAuth = null;
    
    try {
      console.log("Intentando inicializar Firebase...");
      const app = initializeApp(firebaseConfig);
      
      initializedAuth = getAuth(app);
      const initializedDb = getFirestore(app);

      setDb(initializedDb);

      // Listener para el estado de autenticaci√≥n
      unsubscribeAuth = onAuthStateChanged(initializedAuth, (user) => {
        if (user) {
          setCurrentUser(user);
          setStatus(`Autenticado como: ${user.uid}`);
        } else {
          setCurrentUser(null);
          setStatus('Usuario no autenticado. Intentando iniciar sesi√≥n...');
        }
      });

      // L√≥gica de inicio de sesi√≥n inicial (solo an√≥nima)
      const signIn = async () => {
        try {
          await signInAnonymously(initializedAuth);
        } catch (error) {
          console.error('Error de autenticaci√≥n inicial:', error);
          let errorMessage = error.message;

          // Manejo de errores detallado
          if (error.code === 'auth/operation-not-allowed') {
            errorMessage = "ERROR: La autenticaci√≥n an√≥nima NO est√° habilitada en la consola de Firebase. Por favor, habil√≠tala.";
          } else if (error.code === 'auth/configuration-not-found') {
            errorMessage = "ERROR CR√çTICO: Habilita 'Anonymous' en Firebase Authentication -> Sign-in method.";
          } else if (error.code === 'auth/api-key-not-valid') {
            errorMessage = "ERROR CR√çTICO: Clave API inv√°lida. Revisa tu .env.";
          }

          setStatus(`Error de Autenticaci√≥n: ${errorMessage}`);
        }
      };

      signIn();

      // Cleanup
      return () => {
        if (unsubscribeAuth) unsubscribeAuth();
      };
    } catch (error) {
      console.error('Error de inicializaci√≥n de Firebase:', error);
      setStatus(`Error de Inicializaci√≥n: ${error.message}`);
    }
  }, []);

  // 2. Escucha de Mensajes de Firestore
  useEffect(() => {
    if (db && currentUser) {
      setStatus('Cargando mensajes...');
      // Usamos la ruta de datos p√∫blicos: /artifacts/{appId}/public/data/chat_messages
      const collectionPath = `/artifacts/${appId}/public/data/chat_messages`;
      const messagesCollection = collection(db, collectionPath);

      const q = query(messagesCollection, orderBy('timestamp', 'asc'));

      const unsubscribeSnapshot = onSnapshot(q, (snapshot) => {
        const fetchedMessages = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        setMessages(fetchedMessages);
        setStatus('Listo para chatear.');
      }, (error) => {
        console.error('Error al escuchar mensajes:', error);
        setStatus(`Error al cargar mensajes: ${error.message}`);
      });

      // Cleanup
      return () => unsubscribeSnapshot();
    }
  }, [db, currentUser]);

  // 3. Scroll al √∫ltimo mensaje
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

// 4. Enviar Mensaje
const handleSendMessage = useCallback(async (e) => {
  e.preventDefault();
  if (newMessage.trim() === '' || !db || !currentUser) return;

  try {
    const appId = firebaseConfig.projectId;

    // Paso 1: Crear documento base si no existe (Necesario para la estructura de la colecci√≥n)
    const baseDocRef = doc(db, `artifacts/${appId}/public/data`);
    const baseDocSnap = await getDoc(baseDocRef);

    if (!baseDocSnap.exists()) {
      console.log("üìÇ Creando documento base para estructura del chat...");
      await setDoc(baseDocRef, {
        createdAt: serverTimestamp(),
        createdBy: currentUser.uid,
      });
    }

    // Paso 2: insertar mensaje en la colecci√≥n
    const messagesCollection = collection(db, `artifacts/${appId}/public/data/chat_messages`);
    await addDoc(messagesCollection, {
      text: newMessage,
      userId: currentUser.uid,
      timestamp: serverTimestamp(),
    });

    setNewMessage('');
    console.log("‚úÖ Mensaje enviado correctamente.");
  } catch (e) {
    console.error('‚ùå Error al enviar mensaje: ', e);
    setStatus(`Error al enviar: ${e.message}`);
  }
}, [newMessage, db, currentUser]);

  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col font-sans p-4">
      
      {/* Header y Estado */}
      <header className="py-3 px-4 bg-gray-800 rounded-lg shadow-md mb-4 flex justify-between items-center">
        <h1 className="text-xl font-bold text-indigo-400">Secure Chat (ID de App: {appId ? appId.substring(0, 8) + '...' : 'Cargando...'})</h1>
        <div className="text-xs text-gray-400">
          Estado: <span className="font-mono text-sm text-green-400">{status}</span>
        </div>
      </header>

      {/* Mostrar ID de Usuario */}
      {currentUser && (
        <div className="text-xs text-gray-500 mb-2 p-2 bg-gray-800 rounded-lg">
          Tu ID: <span className="font-mono text-yellow-400 break-all">{currentUser.uid}</span>
          <p className="mt-1">Comparte este ID con otros para chatear en esta sala.</p>
        </div>
      )}

      {/* Contenedor de Mensajes */}
      <div className="flex-1 overflow-y-auto space-y-3 p-4 bg-gray-800 rounded-lg shadow-inner mb-4 max-h-[70vh]">
        {messages.length === 0 && <p className="text-center text-gray-500">A√∫n no hay mensajes. ¬°S√© el primero en saludar!</p>}
        {messages.map((msg, index) => {
          const isCurrentUser = currentUser && msg.userId === currentUser.uid;
          const userColor = generateColor(msg.userId);

          return (
            <div
              key={msg.id}
              className={`flex ${isCurrentUser ? 'justify-end' : 'justify-start'}`}
            >
              <div
                className={`max-w-xs md:max-w-md lg:max-w-lg p-3 rounded-xl shadow-lg transition duration-300 transform hover:scale-[1.01] ${
                  isCurrentUser
                    ? 'bg-indigo-600 text-white rounded-br-none'
                    : 'bg-gray-700 text-gray-100 rounded-tl-none'
                }`}
              >
                {!isCurrentUser && (
                  <div className="text-xs font-bold mb-1" style={{ color: userColor }}>
                    {msg.userId}
                  </div>
                )}
                <p className="text-sm break-words">{msg.text}</p>
                <div className={`text-[10px] mt-1 ${isCurrentUser ? 'text-indigo-200 text-right' : 'text-gray-400 text-left'}`}>
                  {msg.timestamp?.toDate().toLocaleTimeString() || 'Enviando...'}
                </div>
              </div>
            </div>
          );
        })}
        <div ref={messagesEndRef} />
      </div>

      {/* Formulario de Entrada */}
      <form onSubmit={handleSendMessage} className="flex space-x-2">
        <input
          type="text"
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          placeholder={currentUser ? "Escribe un mensaje..." : "Conectando al chat..."}
          disabled={!currentUser}
          className="flex-1 p-3 rounded-xl bg-gray-700 text-white placeholder-gray-400 focus:ring-2 focus:ring-indigo-500 focus:outline-none disabled:opacity-50"
        />
        <button
          type="submit"
          disabled={!currentUser || newMessage.trim() === ''}
          className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-xl transition duration-300 shadow-md shadow-indigo-500/50 disabled:bg-gray-600 disabled:shadow-none"
        >
          Enviar
        </button>
      </form>
    </div>
  );
};

export default App;
