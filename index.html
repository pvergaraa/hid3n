<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Conexión Segura - Beta</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Estilo personalizado para fuentes y base -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Fondo oscuro tipo terminal */
            color: #c9d1d9;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container {
            max-width: 480px;
            width: 100%;
            height: 95vh;
            display: flex;
            flex-direction: column;
            background-color: #161b22;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #30363d;
            border-radius: 12px;
            overflow: hidden;
        }
        .chat-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 16px;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 80%;
            padding: 10px 14px;
            border-radius: 12px;
            margin-bottom: 8px;
            word-wrap: break-word;
        }
        .sent {
            background-color: #1f6feb;
            align-self: flex-end;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }
        .received {
            background-color: #21262d;
            align-self: flex-start;
            margin-right: auto;
            border: 1px solid #30363d;
            border-bottom-left-radius: 4px;
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .system-alert {
            background-color: #ff0000;
            color: #ffffff;
            font-weight: bold;
            padding: 8px 12px;
            border-radius: 8px;
            margin: 10px auto;
            text-align: center;
            animation: pulse-red 1s infinite alternate;
        }
        @keyframes pulse-red {
            from { opacity: 0.8; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>

    <div class="container" id="appContainer">

        <!-- Header -->
        <header class="p-4 border-b border-gray-700 flex justify-between items-center bg-[#1a1f26]">
            <h1 class="text-xl font-bold text-[#58a6ff]">:: RED-SECURE ::</h1>
            <div id="headerControls" class="flex space-x-2">
                <!-- Los botones de Bloqueo/Cerrar se inyectan aquí -->
            </div>
        </header>

        <!-- Contenedor Principal de Vistas -->
        <main class="flex-grow p-4 overflow-hidden relative">

            <!-- 1. Pantalla de Bloqueo (Inicial y al Desbloquear) -->
            <div id="pinLockScreen" class="absolute inset-0 bg-[#161b22] z-50 flex flex-col items-center justify-center p-4 transition-opacity duration-300 hidden">
                <div class="p-8 bg-[#21262d] rounded-xl w-full max-w-xs shadow-lg border border-[#30363d]">
                    <h2 class="text-2xl font-bold mb-4 text-center">🔐 Acceso Requerido</h2>
                    <p id="pinInstruction" class="text-sm text-gray-400 mb-6 text-center">Ingresa tu clave numérica de 4 dígitos:</p>
                    <input type="number" id="pinInput" placeholder="Clave (ej: 1234)" maxlength="4" class="w-full p-3 mb-4 rounded-lg bg-[#0d1117] border border-[#30363d] text-center text-2xl tracking-widest focus:ring-[#58a6ff] focus:border-[#58a6ff]" oninput="if(this.value.length > this.maxLength) this.value = this.value.slice(0, this.maxLength);">
                    <button onclick="handlePinInput()" class="w-full bg-[#58a6ff] text-white py-3 rounded-lg font-semibold hover:bg-[#4a8ce6] transition duration-200">
                        Acceder
                    </button>
                    <p id="pinError" class="text-sm text-red-400 mt-3 text-center hidden">Clave incorrecta. Intenta de nuevo.</p>
                </div>
            </div>

            <!-- 2. Pantalla de Conexión (Setup Inicial) -->
            <div id="setupScreen" class="absolute inset-0 bg-[#161b22] z-40 flex flex-col items-center justify-center p-4 transition-opacity duration-300 hidden">
                <div class="p-8 bg-[#21262d] rounded-xl w-full max-w-sm shadow-lg border border-[#30363d]">
                    <h2 class="text-2xl font-bold mb-6 text-center text-[#58a6ff]">Establecer Conexión Única</h2>

                    <div id="roleSelection">
                        <p class="mb-4 text-center">¿Eres quien **genera** el código o quien lo **ingresa**?</p>
                        <button onclick="setRole('host')" class="w-full bg-[#30363d] text-white py-3 rounded-lg font-semibold hover:bg-[#4a5057] transition duration-200 mb-3">
                            Generar Código (HOST)
                        </button>
                        <button onclick="setRole('client')" class="w-full bg-[#30363d] text-white py-3 rounded-lg font-semibold hover:bg-[#4a5057] transition duration-200">
                            Ingresar Código (CLIENTE)
                        </button>
                    </div>

                    <div id="hostArea" class="hidden">
                        <p class="mb-3 text-center text-sm text-gray-400">Paso 1: Define tu PIN de 4 dígitos para futuros accesos.</p>
                        <input type="number" id="hostPinInput" placeholder="PIN de 4 dígitos" maxlength="4" class="w-full p-3 mb-4 rounded-lg bg-[#0d1117] border border-[#30363d] text-center text-lg focus:ring-[#58a6ff] focus:border-[#58a6ff]" oninput="if(this.value.length > this.maxLength) this.value = this.value.slice(0, this.maxLength);">
                        <button onclick="setupPinAndGenerateCode()" class="w-full bg-[#1f6feb] text-white py-3 rounded-lg font-semibold hover:bg-[#1a55b3] transition duration-200">
                            Guardar PIN y Generar Código Único
                        </button>
                    </div>

                    <div id="hostWaitingArea" class="hidden text-center mt-6">
                        <p class="text-yellow-400 mb-2 font-semibold">CÓDIGO ÚNICO GENERADO (COMPARTIR SOLO UNA VEZ):</p>
                        <div class="p-3 bg-[#0d1117] rounded-lg border border-yellow-700 flex justify-between items-center mb-4">
                            <code id="displayCode" class="text-xl font-mono tracking-wider text-yellow-300 select-all">...</code>
                            <button onclick="copyToClipboard(document.getElementById('displayCode').innerText)" class="ml-3 text-gray-400 hover:text-white transition duration-150">
                                <!-- Icono de Copiar (SVG) -->
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-2m-8-7l-4 4m0 0l4 4m-4-4h12"/></svg>
                            </button>
                        </div>
                        <p class="text-sm text-gray-400 mb-4">Esperando que el Cliente ingrese este código...</p>
                        <div class="text-center">
                            <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-10 w-10 mb-4 inline-block"></div>
                        </div>
                        <button onclick="cancelConnectionAndReset()" class="w-full bg-red-600 text-white py-2 rounded-lg font-semibold hover:bg-red-700 transition duration-200 mt-4">
                            Cancelar y Generar Nuevo Código
                        </button>
                    </div>

                    <div id="clientArea" class="hidden">
                        <p class="mb-3 text-center text-sm text-gray-400">Paso 1: Define tu PIN de 4 dígitos para futuros accesos.</p>
                        <input type="number" id="clientPinInput" placeholder="PIN de 4 dígitos" maxlength="4" class="w-full p-3 mb-4 rounded-lg bg-[#0d1117] border border-[#30363d] text-center text-lg focus:ring-[#58a6ff] focus:border-[#58a6ff]" oninput="if(this.value.length > this.maxLength) this.value = this.value.slice(0, this.maxLength);">
                        <p class="mb-3 text-center text-sm text-gray-400">Paso 2: Ingresa el Código Único de 12 caracteres proporcionado.</p>
                        <input type="text" id="joinCodeInput" placeholder="Código Único de 12 caracteres" maxlength="12" class="w-full p-3 mb-4 rounded-lg bg-[#0d1117] border border-[#30363d] text-center text-lg tracking-wider uppercase focus:ring-[#58a6ff] focus:border-[#58a6ff]" oninput="this.value = this.value.toUpperCase();">
                        <button onclick="setupPinAndJoinRoom()" class="w-full bg-green-600 text-white py-3 rounded-lg font-semibold hover:bg-green-700 transition duration-200">
                            Conectar y Unirse al Chat
                        </button>
                        <p id="joinError" class="text-sm text-red-400 mt-3 text-center hidden">No se pudo encontrar el código o la sala.</p>
                    </div>
                </div>
            </div>

            <!-- 3. Pantalla de Chat Activo -->
            <div id="chatScreen" class="h-full flex flex-col transition-opacity duration-300 hidden">
                <div id="chatArea" class="chat-area flex flex-col">
                    <!-- Los mensajes se inyectan aquí -->
                    <div class="system-alert mb-4">
                        Conexión establecida. Cifrado AES-GCM 256 activo.
                    </div>
                </div>
                <!-- Input de Mensaje -->
                <div class="p-4 border-t border-gray-700 bg-[#1a1f26]">
                    <div class="flex space-x-2">
                        <input type="text" id="messageInput" placeholder="Escribe tu mensaje..." class="flex-grow p-3 rounded-lg bg-[#0d1117] border border-[#30363d] text-white focus:ring-[#58a6ff] focus:border-[#58a6ff]" onkeypress="if(event.key === 'Enter') sendMessage()">
                        <button onclick="sendMessage()" class="bg-[#58a6ff] text-white px-4 py-3 rounded-lg font-semibold hover:bg-[#4a8ce6] transition duration-200 flex-shrink-0">
                            Enviar
                        </button>
                    </div>
                </div>
            </div>

            <!-- Modal para Alerta de Error (Reemplaza alert()) -->
            <div id="customAlert" class="hidden fixed inset-0 bg-black bg-opacity-75 z-[9999] flex items-center justify-center">
                <div class="bg-[#21262d] p-6 rounded-xl shadow-2xl border border-[#30363d] w-full max-w-sm">
                    <h3 class="text-xl font-bold text-red-400 mb-4" id="alertTitle">Alerta</h3>
                    <p class="text-gray-300 mb-6" id="alertMessage">Mensaje de alerta.</p>
                    <button onclick="document.getElementById('customAlert').classList.add('hidden')" class="w-full bg-[#58a6ff] text-white py-2 rounded-lg font-semibold hover:bg-[#4a8ce6]">
                        Aceptar
                    </button>
                </div>
            </div>

        </main>
    </div>

    <!-- Carga de Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, query, orderBy, setDoc, addDoc, serverTimestamp, deleteDoc, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase and App State Variables
        setLogLevel('Debug');
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'secure-chat-v1';

        let app;
        let db;
        let auth;
        let userId = null;
        let roomId = null; // The 12-character code, which is also the key derivation source

        let symmetricKey = null; // The derived AES-GCM key object
        let pinHash = null; // Hash of the 4-digit PIN for local lock
        
        // --- Criptografía (Web Crypto API) ---

        /**
         * Deriva la clave simétrica AES-GCM 256-bit usando PBKDF2 desde el código de 12 caracteres.
         * @param {string} code El código de 12 caracteres (PSK).
         * @returns {Promise<CryptoKey>} La clave CryptoKey.
         */
        async function deriveKey(code) {
            const encoder = new TextEncoder();
            const salt = encoder.encode(appId); // Usar el ID de la app como salt fijo
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                encoder.encode(code),
                { name: "PBKDF2" },
                false,
                ["deriveKey"]
            );

            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true, // Exportable (for debugging/storage, but we store it in memory)
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Cifra un mensaje.
         * @param {string} text El mensaje en texto plano.
         * @returns {Promise<{ciphertext: string, iv: string}>} El mensaje cifrado y el IV.
         */
        async function encryptMessage(text) {
            if (!symmetricKey) throw new Error("Clave de cifrado no disponible.");

            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const iv = crypto.getRandomValues(new Uint8Array(12)); // IV de 12 bytes para AES-GCM

            const buffer = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                symmetricKey,
                data
            );

            const ciphertext = arrayBufferToBase64(buffer);
            const ivString = arrayBufferToBase64(iv.buffer);

            return { ciphertext, iv: ivString };
        }

        /**
         * Descifra un mensaje.
         * @param {string} ciphertext El texto cifrado en base64.
         * @param {string} ivString El IV en base64.
         * @returns {Promise<string>} El mensaje descifrado en texto plano.
         */
        async function decryptMessage(ciphertext, ivString) {
            if (!symmetricKey) return "[Mensaje Cifrado - Clave Faltante]";
            
            try {
                const dataBuffer = base64ToArrayBuffer(ciphertext);
                const ivBuffer = base64ToArrayBuffer(ivString);

                const decryptedBuffer = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: new Uint8Array(ivBuffer) },
                    symmetricKey,
                    dataBuffer
                );

                const decoder = new TextDecoder();
                return decoder.decode(decryptedBuffer);
            } catch (error) {
                console.error("Error al descifrar el mensaje:", error);
                return "[Error de Descifrado]";
            }
        }

        // --- Utilidades de Conversión ---

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary_string = atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function hashPin(pin) {
            return pin; // Para simplificar, usamos el pin como hash, pero DEBE ser un hash real en producción.
        }

        // --- Flujo de la Aplicación y Estado ---

        /**
         * Muestra una alerta personalizada (reemplaza alert()).
         * @param {string} title Título de la alerta.
         * @param {string} message Mensaje de la alerta.
         */
        function customAlert(title, message) {
            document.getElementById('alertTitle').innerText = title;
            document.getElementById('alertMessage').innerText = message;
            document.getElementById('customAlert').classList.remove('hidden');
        }
        
        /**
         * Genera un ID de 12 caracteres alfanuméricos.
         * @returns {string} El código de sala.
         */
        function generateRoomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 12; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        /**
         * Navega entre las pantallas (Setup, PIN Lock, Chat).
         */
        function showScreen(screenId) {
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('pinLockScreen').classList.add('hidden');
            document.getElementById('chatScreen').classList.add('hidden');

            document.getElementById(screenId).classList.remove('hidden');
        }

        /**
         * Inicializa la interfaz al cargar.
         * Solo se llama una vez que el usuario (userId) está definido.
         */
        function initializeUI() {
            const storedPinHash = localStorage.getItem('secureChatPinHash');
            const storedRoomId = localStorage.getItem('secureChatRoomId');

            if (storedPinHash && storedRoomId) {
                // Usuario ya configuró la app: pedir PIN
                pinHash = storedPinHash;
                roomId = storedRoomId;
                showScreen('pinLockScreen');
            } else {
                // Primer uso: ir a la configuración
                showScreen('setupScreen');
                document.getElementById('roleSelection').classList.remove('hidden');
                document.getElementById('pinInstruction').innerText = 'Ingresa tu clave numérica de 4 dígitos:';
            }
        }

        // --- Configuración Inicial y Conexión (Pantalla 2) ---

        /**
         * Configura el rol del usuario (Host o Cliente).
         */
        function setRole(role) {
            document.getElementById('roleSelection').classList.add('hidden');
            document.getElementById('hostArea').classList.add('hidden');
            document.getElementById('clientArea').classList.add('hidden');

            if (role === 'host') {
                document.getElementById('hostArea').classList.remove('hidden');
            } else {
                document.getElementById('clientArea').classList.remove('hidden');
            }
        }

        /**
         * Host: Guarda el PIN y genera el código de sala.
         */
        async function setupPinAndGenerateCode() {
            const pin = document.getElementById('hostPinInput').value;
            if (pin.length !== 4 || !/^\d+$/.test(pin)) {
                return customAlert("Error de PIN", "El PIN debe ser una clave numérica de 4 dígitos.");
            }

            pinHash = hashPin(pin);
            roomId = generateRoomId();

            try {
                // 1. Derivar la clave simétrica
                symmetricKey = await deriveKey(roomId);

                // 2. Crear el documento de sala en Firestore (público)
                const roomRef = doc(db, `artifacts/${appId}/public/data/secure_chats`, roomId);
                await setDoc(roomRef, {
                    hostId: userId,
                    createdAt: serverTimestamp(),
                    status: 'waiting', // Estado inicial
                });

                // 3. Persistir la configuración localmente
                localStorage.setItem('secureChatPinHash', pinHash);
                localStorage.setItem('secureChatRoomId', roomId);

                // 4. Mostrar el código y esperar
                document.getElementById('hostArea').classList.add('hidden');
                document.getElementById('displayCode').innerText = roomId;
                document.getElementById('hostWaitingArea').classList.remove('hidden');

                // 5. Iniciar escucha de la sala
                startRoomListener();
                
            } catch (e) {
                console.error("Error al generar código y sala:", e);
                customAlert("Error de Sistema", "No se pudo generar la sala. Revisa la conexión.");
            }
        }

        /**
         * Cliente: Guarda el PIN e intenta unirse a la sala.
         */
        async function setupPinAndJoinRoom() {
            const pin = document.getElementById('clientPinInput').value;
            const code = document.getElementById('joinCodeInput').value.toUpperCase();

            if (pin.length !== 4 || !/^\d+$/.test(pin)) {
                return customAlert("Error de PIN", "Tu PIN debe ser una clave numérica de 4 dígitos.");
            }
            if (code.length !== 12) {
                return customAlert("Error de Código", "El Código Único debe tener 12 caracteres.");
            }

            roomId = code;
            pinHash = hashPin(pin);

            try {
                // 1. Derivar la clave simétrica
                symmetricKey = await deriveKey(roomId);

                // 2. Intentar unirse (si la sala existe, actualiza el estado)
                const roomRef = doc(db, `artifacts/${appId}/public/data/secure_chats`, roomId);

                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);

                    if (!roomDoc.exists() || roomDoc.data().status === 'closed') {
                        throw "ROOM_NOT_FOUND";
                    }

                    // Actualiza el estado de la sala
                    transaction.update(roomRef, {
                        clientId: userId,
                        status: 'active', // Marca la sala como activa
                        joinedAt: serverTimestamp(),
                    });
                });

                // 3. Persistir la configuración localmente
                localStorage.setItem('secureChatPinHash', pinHash);
                localStorage.setItem('secureChatRoomId', roomId);

                // 4. Iniciar el chat
                startChatSession();
                
            } catch (e) {
                console.error("Error al unirse a la sala:", e);
                document.getElementById('joinError').innerText = (e === "ROOM_NOT_FOUND") ? "Código no encontrado o sala ya cerrada." : "Error de conexión. Intenta de nuevo.";
                document.getElementById('joinError').classList.remove('hidden');
                // Borrar clave para forzar nuevo intento
                symmetricKey = null;
                roomId = null;
            }
        }

        /**
         * Host: Resetea el proceso si el código no funciona o se pierde.
         * La solución sugerida es generar un código completamente nuevo.
         */
        function cancelConnectionAndReset() {
            // Eliminar la sala antigua para evitar que alguien se conecte tarde
            if (roomId) {
                 // No es necesario esperar el borrado para continuar
                 deleteRoom(roomId);
            }
            // Limpiar estados y volver a empezar
            pinHash = null;
            symmetricKey = null;
            localStorage.removeItem('secureChatPinHash');
            localStorage.removeItem('secureChatRoomId');
            
            // Volver a la selección de rol
            document.getElementById('hostWaitingArea').classList.add('hidden');
            document.getElementById('roleSelection').classList.remove('hidden');
            initializeUI();
            customAlert("Código Cancelado", "Se ha generado un nuevo Código Único. El anterior ya no es válido.");
        }

        // --- Bloqueo de PIN (Pantalla 1) ---

        /**
         * Maneja el ingreso del PIN para desbloquear la aplicación.
         */
        async function handlePinInput() {
            const inputPin = document.getElementById('pinInput').value;
            const inputHash = hashPin(inputPin);

            if (inputHash === pinHash && roomId) {
                // Desbloqueo exitoso. Derivar la clave y cargar la sesión de chat.
                document.getElementById('pinError').classList.add('hidden');
                
                try {
                    // Re-derivar la clave simétrica con el roomId persistido
                    symmetricKey = await deriveKey(roomId);
                    startChatSession();
                } catch (e) {
                    console.error("Error al re-derivar la clave:", e);
                    // Si falla, forzar reconfiguración
                    resetAppAndLogout();
                    customAlert("Error de Cifrado", "No se pudo restaurar la sesión segura. Por favor, reinicia la conexión.");
                }

            } else {
                document.getElementById('pinError').classList.remove('hidden');
                document.getElementById('pinInput').value = '';
            }
        }

        // --- Chat Activo (Pantalla 3) ---

        /**
         * Inicia la sesión de chat después de la conexión o desbloqueo.
         */
        function startChatSession() {
            showScreen('chatScreen');
            document.getElementById('pinInput').value = ''; // Limpiar PIN
            setupHeaderControls(); // Muestra botones de Bloquear/Cerrar
            startMessagesListener();
            startRoomListener();
            requestNotificationPermission();
        }

        /**
         * Configura los botones de la cabecera (Bloquear/Cerrar Sesión).
         */
        function setupHeaderControls() {
            const controls = document.getElementById('headerControls');
            controls.innerHTML = `
                <button onclick="lockApp()" class="bg-[#21262d] text-gray-300 px-3 py-1 rounded-lg border border-[#30363d] hover:bg-[#30363d] transition duration-200">
                    Bloquear 🔒
                </button>
                <button onclick="closeSessionAndWipe()" class="bg-red-700 text-white px-3 py-1 rounded-lg hover:bg-red-800 transition duration-200">
                    Cerrar App ❌
                </button>
            `;
        }

        /**
         * Listener para el estado de la sala (Host esperando o Cliente unido).
         * Solo es realmente importante para el Host en estado 'waiting'.
         */
        let roomUnsubscribe;
        function startRoomListener() {
            if (roomUnsubscribe) roomUnsubscribe();

            const roomRef = doc(db, `artifacts/${appId}/public/data/secure_chats`, roomId);
            roomUnsubscribe = onSnapshot(roomRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    
                    // Si el estado pasa a 'active' y el Host estaba esperando
                    if (data.status === 'active' && document.getElementById('hostWaitingArea').classList.contains('hidden') === false) {
                        // El cliente se unió
                        document.getElementById('hostWaitingArea').classList.add('hidden');
                        startChatSession();
                    }

                    // Si la sala se cerró remotamente
                    if (data.status === 'closed') {
                        customAlert("SESIÓN CERRADA", "Tu compañero ha cerrado la sesión. El historial de chat ha sido eliminado. Debes iniciar una nueva conexión.");
                        resetAppAndLogout();
                    }
                } else {
                     // Si el documento de sala ya no existe (borrado remoto)
                    if (roomId) {
                        customAlert("CONEXIÓN INTERRUMPIDA", "La sala de chat fue eliminada remotamente. Por favor, reinicia la conexión.");
                        resetAppAndLogout();
                    }
                }
            });
        }

        /**
         * Listener para nuevos mensajes en la colección de chat.
         */
        let messagesUnsubscribe;
        function startMessagesListener() {
            if (messagesUnsubscribe) messagesUnsubscribe();

            const messagesCol = collection(db, `artifacts/${appId}/public/data/secure_chats/${roomId}/messages`);
            const q = query(messagesCol, orderBy("timestamp", "asc"));

            messagesUnsubscribe = onSnapshot(q, (snapshot) => {
                const chatArea = document.getElementById('chatArea');
                // Almacenar el historial para evitar scroll si solo se actualiza
                const currentScrollTop = chatArea.scrollTop;
                const isNearBottom = chatArea.scrollHeight - chatArea.clientHeight <= currentScrollTop + 10;
                
                // Mantenemos los mensajes existentes para evitar un parpadeo, pero los actualizamos.
                // Para simplificar, aquí limpiamos y volvemos a renderizar, pero evitamos el scroll.
                chatArea.innerHTML = ''; 
                
                snapshot.forEach(async (doc) => {
                    const data = doc.data();
                    const decryptedText = await decryptMessage(data.ciphertext, data.iv);
                    renderMessage(data.senderId, decryptedText);

                    // Notificación silenciosa si el mensaje no es mío y la ventana no está enfocada
                    if (data.senderId !== userId && !document.hasFocus()) {
                        sendDisguisedNotification(decryptedText);
                    }
                });
                
                // Mantener el scroll al fondo si ya estaba cerca del fondo
                if (isNearBottom) {
                    chatArea.scrollTop = chatArea.scrollHeight;
                }
            });
        }
        
        /**
         * Renderiza un mensaje en la interfaz.
         */
        function renderMessage(senderId, text) {
            const chatArea = document.getElementById('chatArea');
            const isSent = senderId === userId;
            const alignment = isSent ? 'justify-end' : 'justify-start';

            const messageHtml = `
                <div class="flex ${alignment}">
                    <div class="message-bubble ${isSent ? 'sent' : 'received'}">
                        <p class="text-sm">${text}</p>
                    </div>
                </div>
            `;
            chatArea.innerHTML += messageHtml;
        }

        /**
         * Envía un mensaje cifrado a Firestore.
         */
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            if (!text) return;

            try {
                const { ciphertext, iv } = await encryptMessage(text);
                
                const messagesCol = collection(db, `artifacts/${appId}/public/data/secure_chats/${roomId}/messages`);
                await addDoc(messagesCol, {
                    senderId: userId,
                    ciphertext: ciphertext,
                    iv: iv,
                    timestamp: serverTimestamp(),
                });

                input.value = ''; // Limpiar input
            } catch (e) {
                console.error("Error al enviar o cifrar:", e);
                customAlert("Error de Envío", "No se pudo cifrar o enviar el mensaje. Revisa la clave.");
            }
        }

        // --- Funciones de Seguridad y Sesión ---

        /**
         * Bloquea la aplicación, volviendo a la pantalla de PIN.
         */
        function lockApp() {
            showScreen('pinLockScreen');
        }
        
        /**
         * Cierra la sesión, elimina el historial y resetea la app.
         */
        async function closeSessionAndWipe() {
            if (!roomId) {
                return resetAppAndLogout(); // Si no hay room, solo log out
            }

            // Usar la alerta personalizada en lugar de window.confirm
            showConfirmationModal("Confirmación de Cierre", 
                                  "¿Estás seguro de que quieres cerrar la aplicación? Se eliminará TODO el historial de chat de esta sala para AMBAS partes.",
                                  () => {
                                      performWipe();
                                  });
        }
        
        // Función auxiliar para el modal de confirmación
        function showConfirmationModal(title, message, onConfirm) {
            const modal = document.getElementById('customAlert');
            document.getElementById('alertTitle').innerText = title;
            document.getElementById('alertMessage').innerText = message;
            
            // Reemplazar el botón Aceptar por botones de Confirmar/Cancelar
            const confirmButton = document.createElement('button');
            confirmButton.className = 'w-1/2 bg-red-700 text-white py-2 rounded-lg font-semibold hover:bg-red-800 mr-2';
            confirmButton.innerText = 'Confirmar';
            confirmButton.onclick = () => {
                modal.classList.add('hidden');
                onConfirm();
                // Restaurar botón original de Aceptar (aunque se recrea en customAlert)
            };

            const cancelButton = document.createElement('button');
            cancelButton.className = 'w-1/2 bg-[#30363d] text-gray-300 py-2 rounded-lg font-semibold hover:bg-[#4a5057] ml-2';
            cancelButton.innerText = 'Cancelar';
            cancelButton.onclick = () => {
                modal.classList.add('hidden');
            };

            const buttonContainer = modal.querySelector('#alertMessage').nextElementSibling;
            
            // Limpiar y añadir botones de Confirmar/Cancelar
            const originalAcceptButton = document.createElement('button');
            originalAcceptButton.onclick = () => modal.classList.add('hidden');
            originalAcceptButton.className = 'w-full bg-[#58a6ff] text-white py-2 rounded-lg font-semibold hover:bg-[#4a8ce6]';
            originalAcceptButton.innerText = 'Aceptar';
            
            buttonContainer.innerHTML = '';
            buttonContainer.appendChild(confirmButton);
            buttonContainer.appendChild(cancelButton);
            
            // Guardar el botón original para restaurarlo después del cierre
            modal.originalAcceptButton = originalAcceptButton;


            modal.classList.remove('hidden');
        }

        async function performWipe() {
            try {
                // 1. Borrar la sala de chat, lo que notifica al otro usuario (a través del listener)
                await deleteRoom(roomId);
            } catch (e) {
                console.warn("No se pudo eliminar la sala, pero se eliminará la sesión local.", e);
            }

            // 2. Borrar la sesión local (PIN, RoomId) y resetear
            resetAppAndLogout();
        }

        /**
         * Elimina el documento de la sala en Firestore.
         */
        async function deleteRoom(id) {
            // Nota: Firestore no elimina subcolecciones automáticamente. 
            // Aquí, solo eliminamos el documento padre (la App debe interpretar su ausencia como sala eliminada).
            const roomRef = doc(db, `artifacts/${appId}/public/data/secure_chats`, id);
            await deleteDoc(roomRef);
            console.log(`Sala ${id} marcada para eliminación.`);
        }

        /**
         * Limpia todos los estados locales y vuelve a la pantalla inicial.
         */
        function resetAppAndLogout() {
            if (roomUnsubscribe) roomUnsubscribe();
            if (messagesUnsubscribe) messagesUnsubscribe();

            roomId = null;
            symmetricKey = null;
            pinHash = null;

            localStorage.removeItem('secureChatPinHash');
            localStorage.removeItem('secureChatRoomId');

            document.getElementById('headerControls').innerHTML = '';
            document.getElementById('hostWaitingArea').classList.add('hidden');
            document.getElementById('hostArea').classList.add('hidden');
            document.getElementById('clientArea').classList.add('hidden');
            document.getElementById('roleSelection').classList.remove('hidden');

            initializeUI();
        }

        // --- Notificaciones Disfrazadas ---

        /**
         * Solicita permiso para notificaciones del navegador.
         */
        function requestNotificationPermission() {
             if (!("Notification" in window)) {
                console.log("Este navegador no soporta notificaciones de escritorio.");
            } else if (Notification.permission !== "granted") {
                Notification.requestPermission();
            }
        }

        /**
         * Envía una notificación disfrazada.
         */
        function sendDisguisedNotification(message) {
            if (Notification.permission === "granted") {
                const disguise = getDisguise();
                new Notification(disguise.title, {
                    body: disguise.body,
                    icon: 'https://placehold.co/128x128/ff0000/ffffff?text=!',
                    tag: 'secure-chat-alert', // Para evitar múltiples notificaciones
                });
            }
        }

        /**
         * Obtiene un título y cuerpo aleatorio para disfrazar la alerta.
         */
        function getDisguise() {
            const alerts = [
                { title: "ALERTA CRÍTICA DE SISTEMA", body: "Temperatura de CPU excedida. Revisar Inmediatamente." },
                { title: "ERROR DE SEGURIDAD 0x000F", body: "Fallo de conexión en segundo plano. Recibiendo datos de diagnóstico." },
                { title: "ADVERTENCIA DEL DISPOSITIVO", body: "Espacio de Almacenamiento Cerca del Límite. Liberar Memoria Urgente." },
                { title: "FALLO DE RED E INGRESO", body: "Problemas de cobertura: Actividad inusual detectada." }
            ];
            return alerts[Math.floor(Math.random() * alerts.length)];
        }


        // --- Funciones Auxiliares UI ---

        function copyToClipboard(text) {
            // Revertir a document.execCommand para compatibilidad en iframes
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                document.execCommand('copy');
                customAlert("Copiado", "¡El código ha sido copiado al portapapeles!");
            } catch (err) {
                console.error('Error al intentar copiar al portapapeles', err);
                customAlert("Error de Copiado", "No se pudo copiar el texto. Por favor, cópialo manualmente.");
            }
            
            document.body.removeChild(textarea);
        }

        // --- Inicialización Principal de Firebase ---

        window.onload = function() {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // 1. Listener de autenticación (Se activa al iniciar sesión anónima)
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    // Llama a la lógica de la interfaz SOLO cuando tenemos un ID de usuario válido
                    initializeUI(); 
                } else {
                    // Intento de inicio de sesión anónima (necesario para Firestore)
                    try {
                        const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                        if (token) {
                            await signInWithCustomToken(auth, token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Error de autenticación inicial:", error);
                        customAlert("Error de Auth", "No se pudo iniciar la sesión de usuario. Revisa las credenciales de Firebase.");
                    }
                }
            });
        }
        
        // --- EXPOSICIÓN DE FUNCIONES GLOBALES ---
        // Esto es necesario para que las funciones sean accesibles desde los atributos onclick del HTML.
        window.setRole = setRole;
        window.setupPinAndGenerateCode = setupPinAndGenerateCode;
        window.setupPinAndJoinRoom = setupPinAndJoinRoom;
        window.handlePinInput = handlePinInput;
        window.sendMessage = sendMessage;
        window.lockApp = lockApp;
        window.closeSessionAndWipe = closeSessionAndWipe;
        window.copyToClipboard = copyToClipboard;
        window.cancelConnectionAndReset = cancelConnectionAndReset;
    </script>

</body>
</html>
