<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RED-SECURE Chat</title>
    <script src="https://cdn.tailwindcss.com"></script> 

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        html, body {
            /* Asegura que el body ocupe todo el espacio para el centrado */
            height: 100%; 
            margin: 0;
            padding: 0;
            display: flex; /* CRÍTICO: Para centrar el contenedor */
            align-items: center;
            justify-content: center;
            background-color: #0d1117; 
            font-family: 'Inter', sans-serif;
            color: #c9d1d9;
        }
        
        .container {
            max-width: 480px;
            width: 100%;
            /* CRÍTICO: Altura fija para que no se recorte */
            height: 95vh; 
            display: flex;
            flex-direction: column;
            background-color: #161b22;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #30363d;
            border-radius: 12px;
            overflow: hidden;
        }

        /* Aseguramos que main, donde están las pantallas, ocupe el espacio flexible */
        .container main {
            flex-grow: 1; 
            overflow: hidden; /* Importante para el área de chat */
            position: relative; /* CRÍTICO: Para que setupScreen y pinLockScreen se posicionen correctamente */
        }
        
        .chat-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 16px;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 80%;
            padding: 10px 14px;
            border-radius: 12px;
            margin-bottom: 8px;
            word-wrap: break-word;
        }
        .sent {
            background-color: #1f6feb;
            align-self: flex-end;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }
        .received {
            background-color: #21262d;
            align-self: flex-start;
            margin-right: auto;
            border: 1px solid #30363d;
            border-bottom-left-radius: 4px;
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .system-alert {
            background-color: #30363d; /* Cambio de color para que sea menos intrusivo */
            color: #c9d1d9;
            font-weight: normal;
            padding: 8px 12px;
            border-radius: 8px;
            margin: 10px auto;
            text-align: center;
        }
        .loader {
            border-color: #58a6ff;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <div class="container" id="appContainer">

        <header class="p-4 border-b border-gray-700 flex justify-between items-center bg-[#1a1f26]">
            <h1 class="text-xl font-bold text-[#58a6ff]">:: RED-SECURE ::</h1>
            <div id="headerControls" class="flex space-x-2">
                </div>
        </header>

        <main class="flex-grow p-4 overflow-hidden relative">
            
            <div id="pinLockScreen" class="absolute inset-0 bg-[#161b22] z-50 flex flex-col items-center justify-center p-4 transition-opacity duration-300 hidden">
                <div class="p-8 bg-[#21262d] rounded-xl w-full max-w-sm shadow-lg border border-[#30363d] text-center">
                    <h2 class="text-xl font-bold mb-4 text-[#58a6ff]">Ingreso Requerido</h2>
                    <p class="mb-4 text-gray-400">Ingresa tu PIN de 4 dígitos para acceder a esta sala.</p>
                    
                    <input type="number" id="accessPinInput" placeholder="PIN de 4 dígitos" maxlength="4" class="w-full p-3 mb-4 rounded-lg bg-[#0d1117] border border-[#30363d] text-center text-lg focus:ring-[#58a6ff] focus:border-[#58a6ff]" oninput="if(this.value.length > this.maxLength) this.value = this.value.slice(0, this.maxLength);">
                    
                    <button onclick="unlockApp()" class="w-full bg-green-600 text-white py-3 rounded-lg font-semibold hover:bg-green-700 transition duration-200">
                        Acceder a la Sala
                    </button>
                    
                    <button onclick="closeSessionAndWipe()" class="w-full bg-red-600 text-white py-2 rounded-lg font-semibold hover:bg-red-700 transition duration-200 mt-4">
                        Cerrar Sesión
                    </button>
                    <p id="pinError" class="text-red-400 mt-3 hidden">PIN incorrecto. Intenta de nuevo.</p>
                </div>
            </div>
            
            <div id="setupScreen" class="absolute inset-0 bg-[#161b22] z-40 flex flex-col items-center justify-center p-4 transition-opacity duration-300">
                <div class="p-8 bg-[#21262d] rounded-xl w-full max-w-sm shadow-lg border border-[#30363d]">
                    <h2 class="text-2xl font-bold mb-6 text-center text-[#58a6ff]">Establecer Conexión Única</h2>

                    <div id="roleSelection">
                        <p class="mb-4 text-center">¿Eres quien **genera** el código o quien lo **ingresa**?</p>
                        <button onclick="setRole('host')" class="w-full bg-[#30363d] text-white py-3 rounded-lg font-semibold hover:bg-[#4a5057] transition duration-200 mb-3">
                            Generar Código (HOST)
                        </button>
                        <button onclick="setRole('client')" class="w-full bg-[#30363d] text-white py-3 rounded-lg font-semibold hover:bg-[#4a5057] transition duration-200">
                            Ingresar Código (CLIENTE)
                        </button>
                    </div>
                    
                    <div id="hostArea" class="hidden">
                        <p class="mb-3 text-center text-sm text-gray-400">Paso 1: Define tu PIN de 4 dígitos para futuros accesos.</p>
                        <input type="number" id="hostPinInput" placeholder="PIN de 4 dígitos" maxlength="4" class="w-full p-3 mb-4 rounded-lg bg-[#0d1117] border border-[#30363d] text-center text-lg focus:ring-[#58a6ff] focus:border-[#58a6ff]" oninput="if(this.value.length > this.maxLength) this.value = this.value.slice(0, this.maxLength);">
                        
                        <button onclick="setupPinAndGenerateCode()" class="w-full bg-[#1f6feb] text-white py-3 rounded-lg font-semibold hover:bg-[#1a55b3] transition duration-200">
                            Guardar PIN y Generar Código Único
                        </button>
                    </div>

                    <div id="hostWaitingArea" class="hidden text-center mt-6">
                        <p class="text-yellow-400 mb-2 font-semibold">CÓDIGO ÚNICO GENERADO (COMPARTIR SOLO UNA VEZ):</p>
                        <div class="p-3 bg-[#0d1117] rounded-lg border border-yellow-700 flex justify-between items-center mb-4">
                            <code id="displayCode" class="text-xl font-mono tracking-wider text-yellow-300 select-all">...</code>
                            <button onclick="copyToClipboard(document.getElementById('displayCode').innerText)" class="ml-3 text-gray-400 hover:text-white transition duration-150">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-2m-8-7l-4 4m0 0l4 4m-4-4h12"/></svg>
                            </button>
                        </div>
                        <p class="text-sm text-gray-400 mb-4">Esperando que el Cliente ingrese este código...</p>
                        <div class="text-center">
                            <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-10 w-10 mb-4 inline-block"></div>
                        </div>
                        <button onclick="cancelConnectionAndReset()" class="w-full bg-red-600 text-white py-2 rounded-lg font-semibold hover:bg-red-700 transition duration-200 mt-4">
                            Cancelar y Generar Nuevo Código
                        </button>
                    </div>

                    <div id="clientArea" class="hidden">
                        <p class="mb-3 text-center text-sm text-gray-400">Paso 1: Define tu PIN de 4 dígitos para futuros accesos.</p>
                        <input type="number" id="clientPinInput" placeholder="PIN de 4 dígitos" maxlength="4" class="w-full p-3 mb-4 rounded-lg bg-[#0d1117] border border-[#30363d] text-center text-lg focus:ring-[#58a6ff] focus:border-[#58a6ff]" oninput="if(this.value.length > this.maxLength) this.value = this.value.slice(0, this.maxLength);">
                        <p class="mb-3 text-center text-sm text-gray-400">Paso 2: Ingresa el Código Único de 12 caracteres proporcionado.</p>
                        <input type="text" id="joinCodeInput" placeholder="Código Único de 12 caracteres" maxlength="12" class="w-full p-3 mb-4 rounded-lg bg-[#0d1117] border border-[#30363d] text-center text-lg tracking-wider uppercase focus:ring-[#58a6ff] focus:border-[#58a6ff]" oninput="this.value = this.value.toUpperCase();">
                        <button onclick="setupPinAndJoinRoom()" class="w-full bg-green-600 text-white py-3 rounded-lg font-semibold hover:bg-green-700 transition duration-200">
                            Conectar y Unirse al Chat
                        </button>
                        <p id="joinError" class="text-sm text-red-400 mt-3 text-center hidden">No se pudo encontrar el código o la sala.</p>
                    </div>
                </div>
            </div>
            
            <div id="chatScreen" class="h-full flex flex-col transition-opacity duration-300 hidden">
                <div id="chatArea" class="chat-area flex flex-col">
                    <div class="system-alert mb-4">
                        Conexión establecida. Cifrado AES-GCM 256 activo.
                    </div>
                </div>
                <div class="p-4 border-t border-gray-700 bg-[#1a1f26]">
                    <div class="flex space-x-2">
                        <input type="text" id="messageInput" placeholder="Escribe tu mensaje..." class="flex-grow p-3 rounded-lg bg-[#0d1117] border border-[#30363d] text-white focus:ring-[#58a6ff] focus:border-[#58a6ff]" onkeypress="if(event.key === 'Enter') sendMessage()">
                        <button onclick="sendMessage()" class="bg-[#58a6ff] text-white px-4 py-3 rounded-lg font-semibold hover:bg-[#4a8ce6] transition duration-200 flex-shrink-0">
                            Enviar
                        </button>
                    </div>
                </div>
            </div>

            <div id="customAlert" class="hidden fixed inset-0 bg-black bg-opacity-75 z-[9999] flex items-center justify-center">
                <div class="bg-[#21262d] p-6 rounded-xl shadow-2xl border border-[#30363d] w-full max-w-sm">
                    <h3 class="text-xl font-bold text-red-400 mb-4" id="alertTitle">Alerta</h3>
                    <p class="text-gray-300 mb-6" id="alertMessage">Mensaje de alerta.</p>
                    <button onclick="document.getElementById('customAlert').classList.add('hidden')" class="w-full bg-[#58a6ff] text-white py-2 rounded-lg font-semibold hover:bg-[#4a8ce6]">
                        Aceptar
                    </button>
                </div>
            </div>
            
        </main>
    </div>

    <script type="module">
        // --- 1. Importaciones de Firebase ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, query, orderBy, setDoc, addDoc, serverTimestamp, deleteDoc, runTransaction, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- 2. Configuración de Firebase (ACTUALIZADA con clave correcta) ---
        const firebaseConfig = {
            // Clave API actualizada según la última captura de la consola de Firebase
            apiKey: "AIzaSyA6Si3AUpfOGeZ_Vmi-DZXD1UHDO9l3s0",
            authDomain: "chat-app-f6527.firebaseapp.com",
            projectId: "chat-app-f6527",
            storageBucket: "chat-app-f6527.firebasestorage.app",
            messagingSenderId: "411702105463",
            appId: "1:411702105463:web:66a0c6bc69559cf190bd72"
        };
       
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app); 
        const db = getFirestore(app); 
        const appId = firebaseConfig.appId; 
        setLogLevel('error'); 

        // Variables de Estado Global
        let userId = null; 
        let roomId = null; 
        let symmetricKey = null; 
        let pinHash = null; 
        let messagesUnsubscribe = null;
        let roomUnsubscribe = null;

        // --------------------------------------------------------------------------------
        // --- Criptografía (Web Crypto API) ---
        // --------------------------------------------------------------------------------

        async function deriveKey(code) {
            const encoder = new TextEncoder();
            const salt = encoder.encode(appId); 
            const keyMaterial = await crypto.subtle.importKey(
                "raw",
                encoder.encode(code),
                { name: "PBKDF2" },
                false,
                ["deriveKey"]
            );

            return crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptMessage(text) {
            if (!symmetricKey) throw new Error("Clave de cifrado no disponible.");

            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const iv = crypto.getRandomValues(new Uint8Array(12)); 

            const buffer = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                symmetricKey,
                data
            );

            const ciphertext = arrayBufferToBase64(buffer);
            const ivString = arrayBufferToBase64(iv.buffer);

            return { ciphertext, iv: ivString };
        }

        async function decryptMessage(ciphertext, ivString) {
            if (!symmetricKey) return "[Mensaje Cifrado - Clave Faltante]";
           
            try {
                const dataBuffer = base64ToArrayBuffer(ciphertext);
                const ivBuffer = base64ToArrayBuffer(ivString);

                const decryptedBuffer = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: new Uint8Array(ivBuffer) },
                    symmetricKey,
                    dataBuffer
                );

                const decoder = new TextDecoder();
                return decoder.decode(decryptedBuffer);
            } catch (error) {
                console.error("Error al descifrar el mensaje:", error);
                return "[Error de Descifrado]";
            }
        }

        // --- Utilidades de Conversión ---

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary_string = atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        async function hashPin(pin) {
            const encoder = new TextEncoder();
            const data = encoder.encode(pin);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            return arrayBufferToBase64(hashBuffer);
        }
        
        // Función para copiar al portapapeles (expuesta globalmente)
        window.copyToClipboard = function(text) {
             navigator.clipboard.writeText(text).then(() => {
                customAlert("Copiado", "El código único se ha copiado al portapapeles.");
             }).catch(err => {
                console.error('Error al copiar:', err);
                customAlert("Error", "No se pudo copiar el código automáticamente.");
             });
        }

        // --------------------------------------------------------------------------------
        // --- Flujo de la Aplicación y Funciones de Utilidad (Expuestas Globalmente) ---
        // --------------------------------------------------------------------------------

        function customAlert(title, message) {
            document.getElementById('alertTitle').innerText = title;
            document.getElementById('alertMessage').innerText = message;
            document.getElementById('customAlert').classList.remove('hidden');
        }
        
        function generateRoomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 12; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        /**
         * Muestra o esconde las pantallas principales.
         */
        window.showScreen = function(screenId) {
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('chatScreen').classList.add('hidden');
            document.getElementById('pinLockScreen').classList.add('hidden');

            const screen = document.getElementById(screenId);
            if (screen) {
                 screen.classList.remove('hidden');
            } else {
                 console.error(`Pantalla con ID ${screenId} no encontrada.`);
            }
        }

        /**
         * Bloquea la aplicación (requiere PIN).
         */
        window.lockApp = function() {
            showScreen('pinLockScreen');
        }

        /**
         * Desbloquea la aplicación.
         */
        window.unlockApp = async function() { 
            const pin = document.getElementById('accessPinInput').value;
            const storedHash = localStorage.getItem('secureChatPinHash');

            if (!pin || !storedHash) {
                 document.getElementById('pinError').innerText = "Ingresa el PIN.";
                 document.getElementById('pinError').classList.remove('hidden');
                 return;
            }

            const inputHash = await hashPin(pin);

            if (inputHash === storedHash) {
                document.getElementById('pinError').classList.add('hidden');
                
                const persistedRoomId = localStorage.getItem('secureChatRoomId');
                if(persistedRoomId) {
                    roomId = persistedRoomId;
                    try {
                         // Re-derivar clave y continuar el chat
                        symmetricKey = await deriveKey(roomId);
                        startChatSession();
                    } catch (e) {
                        console.error("Error al re-derivar la clave:", e);
                        resetAppAndLogout();
                        customAlert("Error de Cifrado", "No se pudo restaurar la sesión segura. Reinicia la conexión.");
                    }
                } else {
                    resetAppAndLogout();
                    customAlert("Error de Sesión", "La sala se perdió. Por favor, reinicia la conexión.");
                }
            } else {
                document.getElementById('pinError').innerText = "PIN incorrecto. Intenta de nuevo.";
                document.getElementById('pinError').classList.remove('hidden');
            }
        }


        /**
         * Configura el rol del usuario (Host o Cliente).
         */
        window.setRole = function(role) {
            localStorage.setItem('userRole', role);
            document.getElementById('roleSelection').classList.add('hidden');
            document.getElementById('hostArea').classList.add('hidden');
            document.getElementById('clientArea').classList.add('hidden');
            document.getElementById('hostWaitingArea').classList.add('hidden');

            if (role === 'host') {
                document.getElementById('hostArea').classList.remove('hidden');
            } else {
                document.getElementById('clientArea').classList.remove('hidden');
            }
        }

        /**
         * Host: Guarda el PIN y genera el código de sala.
         */
        window.setupPinAndGenerateCode = async function() {
            const pin = document.getElementById('hostPinInput').value;
            if (pin.length !== 4 || !/^\d+$/.test(pin)) {
                return customAlert("Error de PIN", "El PIN debe ser una clave numérica de 4 dígitos.");
            }

            pinHash = await hashPin(pin); 
            roomId = generateRoomId();

            try {
                symmetricKey = await deriveKey(roomId);
                const roomRef = doc(db, `secure_chats/${roomId}`); 
                await setDoc(roomRef, {
                    hostId: userId,
                    createdAt: serverTimestamp(),
                    status: 'waiting',
                });

                localStorage.setItem('secureChatPinHash', pinHash);
                localStorage.setItem('secureChatRoomId', roomId);

                document.getElementById('hostArea').classList.add('hidden');
                document.getElementById('displayCode').innerText = roomId;
                document.getElementById('hostWaitingArea').classList.remove('hidden');

                startRoomListener();
                
            } catch (e) {
                console.error("Error al generar código y sala:", e);
                customAlert("Error de Sistema", "No se pudo generar la sala. Revisa la conexión y reglas de Firebase.");
            }
        }

        /**
         * Cliente: Guarda el PIN e intenta unirse a la sala.
         */
        window.setupPinAndJoinRoom = async function() {
            const pin = document.getElementById('clientPinInput').value;
            const code = document.getElementById('joinCodeInput').value.toUpperCase();
            document.getElementById('joinError').classList.add('hidden'); // Ocultar error previo

            if (pin.length !== 4 || !/^\d+$/.test(pin)) {
                return customAlert("Error de PIN", "Tu PIN debe ser una clave numérica de 4 dígitos.");
            }
            if (code.length !== 12) {
                return customAlert("Error de Código", "El Código Único debe tener 12 caracteres.");
            }

            roomId = code;
            pinHash = await hashPin(pin);

            try {
                symmetricKey = await deriveKey(roomId);
                const roomRef = doc(db, `secure_chats/${roomId}`);

                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);

                    // Verifica si la sala existe, si está cerrada o si ya tiene un cliente
                    if (!roomDoc.exists() || roomDoc.data().status === 'closed' || roomDoc.data().clientId) {
                        throw "ROOM_NOT_FOUND";
                    }

                    transaction.update(roomRef, {
                        clientId: userId,
                        status: 'active', 
                        joinedAt: serverTimestamp(),
                    });
                });

                localStorage.setItem('secureChatPinHash', pinHash);
                localStorage.setItem('secureChatRoomId', roomId);

                startChatSession();
                
            } catch (e) {
                console.error("Error al unirse a la sala:", e);
                document.getElementById('joinError').innerText = (e === "ROOM_NOT_FOUND") ? "Código no encontrado, sala ya cerrada o ya con cliente." : "Error de conexión. Intenta de nuevo.";
                document.getElementById('joinError').classList.remove('hidden');
                symmetricKey = null;
                roomId = null;
            }
        }

        /**
         * Host: Resetea el proceso si el código no funciona o se pierde.
         */
        window.cancelConnectionAndReset = function() {
            // Se usa deleteRoom para marcar como 'closed' antes de limpiar localmente
            if (roomId) {
                deleteRoom(roomId); 
            }
            
            pinHash = null;
            symmetricKey = null;
            localStorage.removeItem('secureChatPinHash');
            localStorage.removeItem('secureChatRoomId');
            
            document.getElementById('hostWaitingArea').classList.add('hidden');
            document.getElementById('roleSelection').classList.remove('hidden');
            // La UI se inicializará automáticamente con initializeUI() que es llamada al final del código
            initializeUI(); 
            customAlert("Código Cancelado", "Se ha generado un nuevo Código Único. El anterior ya no es válido.");
        }

        // --- Chat Activo ---

        function startChatSession() {
            showScreen('chatScreen');
            document.getElementById('accessPinInput').value = ''; // Limpiar el PIN de la pantalla de bloqueo
            setupHeaderControls();
            startMessagesListener();
            startRoomListener();
            requestNotificationPermission();
        }

        function setupHeaderControls() {
            const controls = document.getElementById('headerControls');
            controls.innerHTML = `
                <button onclick="lockApp()" class="bg-[#21262d] text-gray-300 px-3 py-1 rounded-lg border border-[#30363d] hover:bg-[#30363d] transition duration-200">
                    Bloquear 🔒
                </button>
                <button onclick="closeSessionAndWipe()" class="bg-red-700 text-white px-3 py-1 rounded-lg hover:bg-red-800 transition duration-200">
                    Cerrar App ❌
                </button>
            `;
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();

            if (text === "" || !symmetricKey || !roomId) return;

            try {
                const { ciphertext, iv } = await encryptMessage(text);
                
                await addDoc(collection(db, `secure_chats/${roomId}/messages`), {
                    ciphertext,
                    iv,
                    senderId: userId,
                    timestamp: serverTimestamp()
                });
                input.value = '';
            } catch (e) {
                console.error("Error al enviar mensaje:", e);
                customAlert("Error de Envío", "No se pudo enviar el mensaje cifrado.");
            }
        }
        window.sendMessage = sendMessage;

        function renderMessage(senderId, text) {
            const container = document.getElementById('chatArea');
            const isSent = senderId === userId;
            
            const divFlex = document.createElement('div');
            divFlex.className = `flex ${isSent ? 'justify-end' : 'justify-start'}`;

            const divBubble = document.createElement('div');
            divBubble.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
            
            const pText = document.createElement('p');
            pText.innerText = text;
            
            divBubble.appendChild(pText);
            divFlex.appendChild(divBubble);
            container.appendChild(divFlex);

            container.scrollTop = container.scrollHeight; // Scroll al final
        }

        function startMessagesListener() {
            if (messagesUnsubscribe) messagesUnsubscribe(); // Detiene el listener anterior

            const messagesQuery = query(
                collection(db, `secure_chats/${roomId}/messages`),
                orderBy('timestamp', 'asc')
            );

            // Aseguramos que la alerta de conexión se mantenga visible
            const container = document.getElementById('chatArea');
            container.innerHTML = `<div class="system-alert mb-4">Conexión establecida. Cifrado AES-GCM 256 activo.</div>`; 

            messagesUnsubscribe = onSnapshot(messagesQuery, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === "added") {
                        const messageData = change.doc.data();
                        const decryptedText = await decryptMessage(messageData.ciphertext, messageData.iv);
                        renderMessage(messageData.senderId, decryptedText);
                        if (messageData.senderId !== userId) {
                             sendNotification("Nuevo mensaje cifrado", decryptedText);
                        }
                    }
                });
            }, (error) => {
                console.error("Error en el listener de mensajes:", error);
                customAlert("Error de Chat", "Se perdió la conexión al chat. Por favor, reinicia.");
            });
        }

        function startRoomListener() {
            if (roomUnsubscribe) roomUnsubscribe();

            const roomRef = doc(db, `secure_chats/${roomId}`);
            
            roomUnsubscribe = onSnapshot(roomRef, (doc) => {
                if (!doc.exists() || doc.data().status === 'closed') {
                    if (roomId) { // Sólo si ya estábamos en una sala
                        customAlert("Sala Cerrada", "La conexión ha sido terminada por el otro usuario.");
                        resetAppAndLogout();
                    }
                    return;
                }
                // Si el host está esperando y el cliente se une
                if (localStorage.getItem('userRole') === 'host' && doc.data().status === 'active' && !messagesUnsubscribe) {
                     startChatSession();
                }
            }, (error) => {
                 console.error("Error en el listener de sala:", error);
            });
        }

        /**
         * Host: Cierra la sala marcándola como 'closed' en lugar de borrarla inmediatamente, 
         * lo que permite al listener del cliente reaccionar.
         */
        async function deleteRoom(id) {
            try {
                const roomRef = doc(db, `secure_chats/${id}`);
                // Cambia el estado a 'closed'
                await setDoc(roomRef, { status: 'closed' }, { merge: true }); 
            } catch (e) {
                console.error("Error al cerrar la sala:", e);
            }
            // Retraso opcional para que el listener del cliente capte el cambio
            setTimeout(async () => {
                try {
                     await deleteDoc(doc(db, `secure_chats/${id}`));
                } catch (e) {
                    console.error("Error al borrar la sala después del cierre:", e);
                }
            }, 5000);
        }

        function resetAppAndLogout() {
            if (messagesUnsubscribe) messagesUnsubscribe();
            if (roomUnsubscribe) roomUnsubscribe();
            symmetricKey = null;
            pinHash = null;
            roomId = null;
            localStorage.clear(); 
            
            auth.signOut(); 
            
            // Forzar una recarga para iniciar el proceso de Auth de nuevo.
            window.location.reload(); 
        }
        window.closeSessionAndWipe = function() {
             // El host llama a deleteRoom, luego todos llaman a resetAppAndLogout()
             if (roomId) {
                 deleteRoom(roomId).then(resetAppAndLogout);
             } else {
                 resetAppAndLogout();
             }
        }
        window.resetAppAndLogout = resetAppAndLogout;
        
        // --- Notificaciones ---
        function requestNotificationPermission() {
            if (!("Notification" in window)) return;
            if (Notification.permission !== "granted") {
                Notification.requestPermission();
            }
        }

        function sendNotification(title, body) {
            if (Notification.permission === "granted" && document.hidden) {
                new Notification(title, { body: body, icon: './favicon.ico' });
            }
        }

        // --- Lógica de Inicialización ---
        function initializeUI() {
            const persistedRoomId = localStorage.getItem('secureChatRoomId');
            const persistedPinHash = localStorage.getItem('secureChatPinHash');
            const persistedRole = localStorage.getItem('userRole');

            if (persistedRoomId && persistedPinHash && persistedRole) {
                // Si hay sesión persistente, pedimos PIN
                roomId = persistedRoomId;
                pinHash = persistedPinHash;
                showScreen('pinLockScreen');
                document.getElementById('pinError').classList.add('hidden');
            } else {
                // Si no hay sesión, mostramos la configuración inicial
                showScreen('setupScreen');
                document.getElementById('roleSelection').classList.remove('hidden');
                document.getElementById('hostArea').classList.add('hidden');
                document.getElementById('clientArea').classList.add('hidden');
            }
        }

        // --- Autenticación y Carga de la UI ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                initializeUI(); 
            } else {
                signInAnonymously(auth)
                    .then(() => {
                        // El listener se dispara de nuevo con el usuario
                    })
                    .catch((error) => {
                        console.error("Error al iniciar sesión anónima:", error);
                        // Mostrar la alerta de Firebase Auth
                        customAlert("Error de Auth", "No se pudo iniciar la sesión anónima de Firebase. Revisa tu conexión y las reglas de seguridad.");
                        
                        // Opcional: Mostrar la pantalla de configuración sin botones si falla
                        // showScreen('setupScreen'); 
                    });
            }
        });
    </script>
</body>
</html>
